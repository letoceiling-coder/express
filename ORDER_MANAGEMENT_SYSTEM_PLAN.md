# План реализации системы управления заказами с ролями и уведомлениями

## Введение

Данный план описывает поэтапную реализацию системы управления заказами с участием ролей: администратор, кухня, курьер, клиент. Система предусматривает автоматические уведомления, управление статусами заказов и логирование всех действий.

---

## Пункт 1: Анализ требований и проектирование структуры данных

### 1.1 Роли пользователей бота
- **Пользователь** (user) - базовая роль, клиент
- **Администратор** (admin) - управление заказами
- **Кухня** (kitchen) - обработка заказов на кухне (новая роль)
- **Курьер** (courier) - доставка заказов

### 1.2 Статусы заказов (существующие + новые)
- `new` - новый заказ (создан клиентом)
- `accepted` - принят (администратор получил уведомление и подтвердил)
- `sent_to_kitchen` - отправлен на кухню
- `kitchen_accepted` - кухня приняла заказ
- `preparing` - готовится (существующий)
- `ready_for_delivery` - готов к доставке (кухня выполнила)
- `courier_assigned` - курьер назначен
- `in_transit` - в пути (курьер забрал)
- `delivered` - доставлен
- `cancelled` - отменен

### 1.3 Необходимые изменения в базе данных
- Добавить роль `kitchen` в таблицу `telegram_users` (расширение существующего поля `role`)
- Создать таблицу `order_status_history` для логирования изменений статусов
- Возможно расширение таблицы `orders` для хранения дополнительных данных

### 1.4 Компоненты системы
1. Backend (Laravel):
   - Расширение модели TelegramUser
   - Обновление OrderController
   - Создание сервисов для уведомлений
   - Создание сервисов для управления статусами
   - Команды бота для ролей
   
2. Telegram Bot:
   - Команда `/apply_kitchen` для подачи заявки на роль кухни
   - Callback handlers для inline кнопок
   - Уведомления всем ролям
   
3. Frontend (Admin Panel):
   - Логирование истории статусов
   - Отображение процесса обработки заказа

---

**Статус:** ✅ Пункт 1 завершен

---

## Пункт 2: Добавление роли "кухня" в систему

### 2.1 Обновление констант ролей в модели TelegramUser
- Добавить константу `ROLE_KITCHEN = 'kitchen'` в `app/Models/TelegramUser.php`
- Обновить валидацию ролей в сеттере `setRoleAttribute`

### 2.2 Обновление миграции/модели TelegramUserRoleRequest
- Добавить поддержку роли `kitchen` в `TelegramUserRoleRequest`
- Обновить константы `ROLE_KITCHEN`

### 2.3 Создание команды бота `/apply_kitchen`
- В `app/Http/Controllers/Api/BotController.php`
- Добавить обработчик команды `/apply_kitchen`
- Использовать существующий метод `handleRoleRequest` с параметром `'kitchen'`

### 2.4 Обновление админ-панели для обработки заявок на роль кухни
- В `app/Services/AdminMenu.php` - заявки на кухню уже должны обрабатываться через существующую систему
- Проверить, что `RoleRequests.vue` корректно отображает все роли

### 2.5 Тестирование
- Проверить создание заявки через команду `/apply_kitchen`
- Проверить одобрение/отклонение заявки в админ-панели
- Проверить отправку уведомления пользователю

**Файлы для изменения:**
- `app/Models/TelegramUser.php`
- `app/Models/TelegramUserRoleRequest.php`
- `app/Http/Controllers/Api/BotController.php`

---

**Статус:** ✅ Пункт 2 завершен

---

## Пункт 3: Расширение статусов заказов и создание таблицы истории статусов

### 3.1 Добавление новых констант статусов в модель Order
- Добавить константы для новых статусов:
  - `STATUS_SENT_TO_KITCHEN = 'sent_to_kitchen'`
  - `STATUS_KITCHEN_ACCEPTED = 'kitchen_accepted'`
  - `STATUS_COURIER_ASSIGNED = 'courier_assigned'`
- Обновить метод валидации статусов

### 3.2 Создание миграции для таблицы order_status_history
- Таблица должна содержать:
  - `id` - первичный ключ
  - `order_id` - внешний ключ на orders
  - `status` - новый статус
  - `previous_status` - предыдущий статус (nullable)
  - `changed_by_user_id` - ID пользователя админ-панели (nullable, FK на users)
  - `changed_by_telegram_user_id` - ID пользователя бота (nullable, FK на telegram_users)
  - `role` - роль пользователя, изменившего статус (admin, kitchen, courier)
  - `comment` - комментарий к изменению (текст, nullable)
  - `metadata` - JSON поле для дополнительных данных (nullable)
  - `created_at`, `updated_at` - временные метки
- Индексы: `order_id`, `status`, `created_at`

### 3.3 Создание модели OrderStatusHistory
- Модель `app/Models/OrderStatusHistory.php`
- Отношения: `belongsTo(Order)`, `belongsTo(User)`, `belongsTo(TelegramUser)`
- Scopes для фильтрации по статусу, роли, дате

### 3.4 Обновление модели Order
- Добавить отношение `hasMany(OrderStatusHistory)`
- Метод для получения истории изменений статусов

**Файлы для создания:**
- `database/migrations/XXXX_create_order_status_history_table.php`
- `app/Models/OrderStatusHistory.php`

**Файлы для изменения:**
- `app/Models/Order.php`

---

**Статус:** ✅ Пункт 3 завершен

---

## Пункт 4: Создание сервиса для управления статусами заказов

### 4.1 Создание сервиса OrderStatusService
- Файл `app/Services/Order/OrderStatusService.php`
- Методы:
  - `changeStatus(Order $order, string $newStatus, array $options = [])` - изменение статуса с логированием
  - `logStatusChange(Order $order, string $status, array $data)` - запись в историю
  - `getStatusHistory(Order $order)` - получение истории статусов
  - `canChangeStatus(Order $order, string $newStatus, string $role)` - проверка возможности изменения

### 4.2 Логика изменения статусов
- Валидация переходов между статусами
- Запись в таблицу `order_status_history`
- Обновление статуса заказа
- Возврат результата операции

### 4.3 Валидация переходов статусов
- Определить допустимые переходы для каждой роли:
  - Администратор: new → accepted, accepted → sent_to_kitchen, accepted → courier_assigned
  - Кухня: sent_to_kitchen → kitchen_accepted, kitchen_accepted → preparing, preparing → ready_for_delivery
  - Курьер: courier_assigned → in_transit, in_transit → delivered
  - Клиент: любой статус → cancelled (с причиной)

**Файлы для создания:**
- `app/Services/Order/OrderStatusService.php`

---

**Статус:** ✅ Пункт 4 завершен

---

## Пункт 5: Создание сервиса для уведомлений о заказах

### 5.1 Создание сервиса OrderNotificationService
- Файл `app/Services/Order/OrderNotificationService.php`
- Методы:
  - `notifyAdminNewOrder(Order $order)` - уведомление администратора о новом заказе
  - `notifyAdminStatusChange(Order $order, string $status, array $details)` - уведомление администратора об изменении статуса
  - `notifyKitchenOrderSent(Order $order)` - уведомление кухни о новом заказе
  - `notifyCourierOrderReady(Order $order, TelegramUser $courier)` - уведомление курьера о готовности
  - `notifyClientStatusChange(Order $order, string $status)` - уведомление клиента об изменении статуса

### 5.2 Форматирование сообщений
- Создать методы форматирования для каждого типа уведомления
- Включить информацию о заказе: номер, товары, сумма, адрес доставки

### 5.3 Использование TelegramService
- Использовать существующий `TelegramService` для отправки сообщений
- Поддержка inline кнопок через `reply_markup`

**Файлы для создания:**
- `app/Services/Order/OrderNotificationService.php`

---

**Статус:** ✅ Пункт 5 завершен

---

## Пункт 6: Обновление OrderController - уведомление администратора при создании заказа

### 6.1 Изменение метода store в OrderController
- После создания заказа вызывать `OrderNotificationService::notifyAdminNewOrder()`
- После успешной отправки уведомления автоматически менять статус на `accepted`
- Использовать `OrderStatusService::changeStatus()` для изменения статуса
- Логировать все действия

### 6.2 Формат уведомления администратору
- Информация о заказе: номер, товары, сумма, адрес, время доставки
- Inline кнопки: "Отправить на кухню", "Вызвать курьера"
- Callback data: `order_action:{order_id}:{action}`

**Файлы для изменения:**
- `app/Http/Controllers/Api/v1/OrderController.php`

---

**Статус:** ✅ Пункт 6 завершен

---

## Пункт 7: Функционал кухни - переход на "preparing" и кнопка "Заказ готов"

### 7.1 Переход статуса на "preparing"
- После принятия заказа кухней (пункт 11) статус меняется с `kitchen_accepted` на `preparing`
- Это может быть автоматически после принятия, или через отдельную кнопку "Начать готовить"
- Использовать `OrderStatusService::changeStatus()` с ролью `kitchen`
- Записать в историю статусов

### 7.2 Обработка callback от кухни "Заказ готов"
- Создать endpoint для обработки callback: `order_kitchen_ready:{order_id}`
- В `app/Http/Controllers/Api/BotController.php` добавить обработчик callback
- При нажатии кнопки:
  - Изменить статус заказа с `preparing` на `ready_for_delivery`
  - Использовать `OrderStatusService::changeStatus()` с ролью `kitchen`
  - Записать в историю статусов

### 7.3 Уведомление администратора о готовности заказа
- После изменения статуса вызывать `OrderNotificationService::notifyAdminStatusChange()`
- Сообщение администратору: "Заказ #XXX готов к доставке"
- Включить информацию о заказе: номер, адрес доставки, список товаров
- Кнопка для вызова курьера (если еще не назначен)

### 7.4 Уведомление клиента
- Одновременно уведомить клиента через `notifyClientStatusChange()`
- Сообщение: "Ваш заказ готов и ожидает курьера"

**Файлы для изменения:**
- `app/Http/Controllers/Api/BotController.php`

**Файлы для использования:**
- `app/Services/Order/OrderStatusService.php`
- `app/Services/Order/OrderNotificationService.php`

---

**Статус:** ✅ Пункт 7 завершен

---

## Пункт 8: Функционал курьера - доставка заказа и прием оплаты

### 8.1 Обработка callback "Заказ доставлен" от курьера
- Создать endpoint для обработки callback: `order_courier_delivered:{order_id}`
- В `app/Http/Controllers/Api/BotController.php` добавить обработчик callback
- При нажатии кнопки "Доставлен":
  - Проверить статус оплаты заказа
  - Если оплата не требуется (payment_status = 'succeeded') или оплата при получении:
    - Изменить статус заказа на `delivered`
    - Использовать `OrderStatusService::changeStatus()` с ролью `courier`
    - Записать в историю статусов

### 8.2 Обработка оплаты курьером (если требуется)
- Если payment_status = 'pending' (заказ не оплачен):
  - Показать курьеру кнопки: "Оплата получена", "Оплата не получена"
  - Callback data: `order_payment:{order_id}:{status}` (received/not_received)
  - При нажатии "Оплата получена":
    - Изменить payment_status на 'succeeded'
    - Изменить статус заказа на `delivered`
    - Записать в историю статусов и платежей
  - При нажатии "Оплата не получена":
    - Оставить payment_status = 'pending'
    - Изменить статус заказа на `delivered`
    - Добавить комментарий в историю о проблеме с оплатой

### 8.3 Уведомление администратора о доставке
- После доставки вызывать `OrderNotificationService::notifyAdminStatusChange()`
- Сообщение администратору: "Заказ #XXX доставлен курьером"
- Включить информацию: номер заказа, адрес, статус оплаты, имя курьера
- Если оплата не получена - добавить предупреждение

### 8.4 Уведомление клиента о доставке
- Уведомить клиента через `notifyClientStatusChange()`
- Сообщение: "Ваш заказ доставлен! Спасибо за заказ!"
- Если оплата не получена - добавить информацию об оплате

### 8.5 Обновление платежной информации в заказе
- Обновить поле `payment_status` в таблице `orders`
- При необходимости создать запись в таблице `payments` (если используется)
- Сохранить информацию о курьере, который принял оплату (в metadata или отдельное поле)

**Файлы для изменения:**
- `app/Http/Controllers/Api/BotController.php`

**Файлы для использования:**
- `app/Services/Order/OrderStatusService.php`
- `app/Services/Order/OrderNotificationService.php`
- `app/Models/Order.php` (для обновления payment_status)

---

**Статус:** ✅ Пункт 8 завершен

---

## Пункт 9: Обработка callback_query в BotController

### 9.1 Добавление обработки callback_query в handleWebhook
- В `app/Http/Controllers/Api/BotController.php` добавить обработку `callback_query` в методе `handleWebhook`
- Проверять наличие `$update['callback_query']`
- Извлекать `callback_data`, `from`, `message`, `callback_query_id`
- Вызывать метод для обработки callback

### 9.2 Создание метода handleCallbackQuery
- Создать приватный метод `handleCallbackQuery(array $callbackQuery, Bot $bot)`
- Парсить `callback_data` по формату: `action:order_id:param`
- Определять тип действия и вызывать соответствующий обработчик
- Отвечать на callback через `answerCallbackQuery` для удаления индикатора загрузки

### 9.3 Формат callback_data
- `order_action:{order_id}:{action}` - действия администратора (send_to_kitchen, call_courier)
- `order_kitchen_accept:{order_id}` - кухня принимает заказ
- `order_kitchen_ready:{order_id}` - заказ готов на кухне
- `order_courier_assign:{order_id}:{courier_telegram_user_id}` - назначение курьера
- `order_courier_picked:{order_id}` - курьер забрал заказ
- `order_courier_delivered:{order_id}` - курьер доставил заказ
- `order_payment:{order_id}:{status}` - обработка оплаты (received/not_received)
- `order_cancel:{order_id}` - отмена заказа (требует ввода причины)

**Файлы для изменения:**
- `app/Http/Controllers/Api/BotController.php`

**Файлы для использования:**
- `app/Services/TelegramService.php` (метод answerCallbackQuery)

---

**Статус:** ✅ Пункт 9 завершен

---

## Пункт 10: Обработка кнопки "Отправить на кухню" от администратора

### 10.1 Обработка callback "send_to_kitchen"
- В `handleCallbackQuery` добавить обработку `order_action:{order_id}:send_to_kitchen`
- Получить заказ по ID
- Изменить статус заказа с `accepted` на `sent_to_kitchen`
- Использовать `OrderStatusService::changeStatus()` с ролью `admin`
- Записать в историю статусов

### 10.2 Уведомление кухни о новом заказе
- Вызвать `OrderNotificationService::notifyKitchenOrderSent($order)`
- Найти всех пользователей с ролью `kitchen` для данного бота
- Отправить каждому кухне уведомление с информацией о заказе
- Inline кнопки: "Принять заказ", "Посмотреть детали"
- Callback data: `order_kitchen_accept:{order_id}`, `order_details:{order_id}`

### 10.3 Уведомление администратора
- После отправки на кухню уведомить администратора об изменении статуса
- Сообщение: "Заказ #XXX отправлен на кухню"

### 10.4 Уведомление клиента
- Уведомить клиента через `notifyClientStatusChange()`
- Сообщение: "Ваш заказ принят и отправлен на кухню"

**Файлы для изменения:**
- `app/Http/Controllers/Api/BotController.php`

**Файлы для использования:**
- `app/Services/Order/OrderStatusService.php`
- `app/Services/Order/OrderNotificationService.php`

---

**Статус:** ✅ Пункт 10 завершен

---

## Пункт 11: Обработка кнопки "Принять заказ" от кухни

### 11.1 Обработка callback "kitchen_accept"
- В `handleCallbackQuery` добавить обработку `order_kitchen_accept:{order_id}`
- Проверить, что пользователь имеет роль `kitchen`
- Проверить, что заказ в статусе `sent_to_kitchen`
- Получить заказ по ID
- Изменить статус заказа с `sent_to_kitchen` на `kitchen_accepted`
- Использовать `OrderStatusService::changeStatus()` с ролью `kitchen`
- Записать в историю статусов с указанием пользователя кухни

### 11.2 Переход статуса на "preparing"
- После принятия заказа автоматически изменить статус с `kitchen_accepted` на `preparing`
- Использовать `OrderStatusService::changeStatus()` с ролью `kitchen`
- Записать в историю статусов

### 11.3 Уведомление администратора
- После принятия заказа кухней вызвать `OrderNotificationService::notifyAdminStatusChange()`
- Сообщение администратору: "Заказ #XXX принят кухней"
- Включить информацию о кухне, принявшей заказ
- Кнопка "Посмотреть детали заказа"

### 11.4 Обновление сообщения кухне
- После принятия заказа изменить сообщение у кухни
- Показать кнопку "Заказ готов" (будет обработана в пункте 7)
- Возможность указать время выполнения (опционально, через кнопку "Указать время")

### 11.5 Уведомление клиента
- Уведомить клиента через `notifyClientStatusChange()`
- Сообщение: "Ваш заказ принят на кухне и начал готовиться"

**Файлы для изменения:**
- `app/Http/Controllers/Api/BotController.php`

**Файлы для использования:**
- `app/Services/Order/OrderStatusService.php`
- `app/Services/Order/OrderNotificationService.php`

---

**Статус:** ✅ Пункт 11 завершен

---

## Пункт 12: Указание времени выполнения заказа кухней

### 12.1 Добавление поля estimated_completion_time
- В таблицу `orders` добавить поле `estimated_completion_time` (datetime, nullable)
- Или использовать поле `metadata` для хранения времени выполнения
- Создать миграцию для добавления поля (если используется отдельное поле)

### 12.2 Обработка указания времени
- Добавить кнопку "Указать время выполнения" в сообщении кухне (после принятия заказа)
- Callback data: `order_kitchen_set_time:{order_id}`
- При нажатии кнопки отправить запрос на ввод времени (через сообщение или inline keyboard с вариантами)
- Альтернатива: отправить сообщение с инструкцией и кнопкой "Указать время", затем обработать ответ пользователя

### 12.3 Сохранение времени выполнения
- Сохранить указанное время в заказ (поле `estimated_completion_time` или `metadata`)
- Записать в историю статусов с указанием времени
- Обновить статус заказа (опционально, или оставить `kitchen_accepted`)

### 12.4 Уведомление администратора и клиента
- Уведомить администратора о времени выполнения заказа
- Уведомить клиента: "Ваш заказ будет готов примерно в [время]"

**Файлы для создания:**
- `database/migrations/XXXX_add_estimated_completion_time_to_orders_table.php` (если используется отдельное поле)

**Файлы для изменения:**
- `app/Http/Controllers/Api/BotController.php`
- `app/Models/Order.php`
- `app/Services/Order/OrderStatusService.php`

---

**Статус:** ✅ Пункт 12 завершен

---

## Пункт 13: Обработка кнопки "Вызвать курьера" и выбор курьера

### 13.1 Обработка callback "call_courier"
- В `handleCallbackQuery` добавить обработку `order_action:{order_id}:call_courier`
- Получить заказ по ID
- Проверить, что заказ в статусе `ready_for_delivery` или `accepted`
- Найти всех пользователей с ролью `courier` для данного бота
- Отправить администратору список курьеров с inline кнопками
- Формат кнопок: имя курьера + статус (если доступен)

### 13.2 Формирование списка курьеров
- Запрос к `TelegramUser::where('bot_id', $bot->id)->where('role', 'courier')->get()`
- Для каждого курьера создать кнопку с именем и ID
- Callback data: `order_courier_assign:{order_id}:{courier_telegram_user_id}`
- Добавить кнопку "Отмена" (callback: `order_cancel_assign:{order_id}`)

### 13.3 Обработка выбора курьера
- В `handleCallbackQuery` добавить обработку `order_courier_assign:{order_id}:{courier_telegram_user_id}`
- Получить заказ и курьера по ID
- Изменить статус заказа на `courier_assigned`
- Использовать `OrderStatusService::changeStatus()` с ролью `admin`
- Записать в историю статусов с указанием назначенного курьера
- Сохранить ID курьера в заказе (если есть поле `courier_id`, иначе в metadata)

### 13.4 Уведомление курьера
- Вызвать `OrderNotificationService::notifyCourierOrderReady($order, $courier)`
- Сообщение курьеру с информацией о заказе: номер, адрес, товары, сумма
- Inline кнопки: "Забрал заказ", "Посмотреть детали"
- Callback data: `order_courier_picked:{order_id}`, `order_details:{order_id}`

### 13.5 Уведомление администратора
- Уведомить администратора: "Курьер [имя] назначен на заказ #XXX"
- Обновить предыдущее сообщение (если возможно) или отправить новое

### 13.6 Уведомление клиента
- Уведомить клиента: "Курьер назначен и скоро заберет ваш заказ"

**Файлы для изменения:**
- `app/Http/Controllers/Api/BotController.php`
- `app/Services/Order/OrderNotificationService.php`

**Файлы для использования:**
- `app/Services/Order/OrderStatusService.php`
- `app/Models/TelegramUser.php`

---

**Статус:** ✅ Пункт 13 завершен

---

## Пункт 14: Обработка кнопки "Забрал заказ" от курьера

### 14.1 Обработка callback "courier_picked"
- В `handleCallbackQuery` добавить обработку `order_courier_picked:{order_id}`
- Проверить, что пользователь имеет роль `courier`
- Проверить, что курьер назначен на этот заказ (сравнить ID курьера)
- Проверить, что заказ в статусе `courier_assigned`
- Получить заказ по ID
- Изменить статус заказа с `courier_assigned` на `in_transit`
- Использовать `OrderStatusService::changeStatus()` с ролью `courier`
- Записать в историю статусов

### 14.2 Обновление сообщения курьеру
- После подтверждения "Забрал заказ" изменить сообщение у курьера
- Показать кнопку "Доставлен" (будет обработана в пункте 8)
- Callback data: `order_courier_delivered:{order_id}`

### 14.3 Уведомление администратора
- Вызвать `OrderNotificationService::notifyAdminStatusChange()`
- Сообщение: "Курьер [имя] забрал заказ #XXX"
- Включить информацию о заказе и курьере

### 14.4 Уведомление клиента
- Уведомить клиента через `notifyClientStatusChange()`
- Сообщение: "Курьер забрал ваш заказ и следует по адресу доставки"

**Файлы для изменения:**
- `app/Http/Controllers/Api/BotController.php`

**Файлы для использования:**
- `app/Services/Order/OrderStatusService.php`
- `app/Services/Order/OrderNotificationService.php`

---

**Статус:** ✅ Пункт 14 завершен

---

## Пункт 15: Отмена заказа клиентом

### 15.1 Добавление кнопки "Отменить заказ" для клиента
- В `OrderNotificationService::notifyClientStatusChange()` добавлять кнопку "Отменить заказ" для всех статусов, кроме `delivered` и `cancelled`
- Callback data: `order_cancel_request:{order_id}`

### 15.2 Обработка запроса на отмену
- В `handleCallbackQuery` добавить обработку `order_cancel_request:{order_id}`
- Проверить, что пользователь является владельцем заказа (сравнить `telegram_id`)
- Проверить, что заказ может быть отменен (не в статусах `delivered`, `cancelled`)
- Отправить клиенту запрос на ввод причины отмены
- Использовать временное состояние (сохранить в сессии/cache) для ожидания ответа пользователя

### 15.3 Обработка причины отмены
- Обработать текстовое сообщение от пользователя (если предыдущий callback был `order_cancel_request`)
- Проверить временное состояние пользователя
- Сохранить причину отмены
- Изменить статус заказа на `cancelled`
- Использовать `OrderStatusService::changeStatus()` с ролью `user`
- Записать причину отмены в комментарий истории статусов

### 15.4 Уведомление администратора
- Уведомить администратора об отмене заказа
- Сообщение: "Заказ #XXX отменен клиентом"
- Включить причину отмены
- Информация о заказе

### 15.5 Уведомление кухни и курьера (если применимо)
- Если заказ был на кухне или у курьера, уведомить их об отмене
- Сообщение: "Заказ #XXX отменен клиентом"

### 15.6 Уведомление клиента
- Подтвердить отмену клиенту
- Сообщение: "Ваш заказ #XXX отменен"

**Файлы для изменения:**
- `app/Http/Controllers/Api/BotController.php`
- `app/Services/Order/OrderNotificationService.php`

**Файлы для использования:**
- `app/Services/Order/OrderStatusService.php`
- `app/Models/Order.php`

---

**Статус:** ✅ Пункт 15 завершен

---

## Пункт 16: Отображение истории статусов в админ-панели

### 16.1 Создание API endpoint для истории статусов
- В `OrderController` добавить метод `statusHistory($id)`
- Route: `GET /api/v1/orders/{id}/status-history`
- Возвращать историю статусов с пагинацией
- Включить информацию о пользователях, изменивших статусы

### 16.2 Создание Vue компонента для истории статусов
- Создать компонент `OrderStatusHistory.vue` в админ-панели
- Отображать список изменений статусов в хронологическом порядке
- Показывать: статус, время, пользователь (роль), комментарий
- Стилизовать как timeline (линия времени)

### 16.3 Интеграция в страницу заказа
- В странице детального просмотра заказа добавить вкладку/секцию "История статусов"
- Использовать компонент `OrderStatusHistory.vue`
- Загружать историю через API при открытии страницы заказа

### 16.4 Фильтрация и поиск
- Добавить возможность фильтрации по роли, статусу, дате
- Добавить поиск по комментариям

**Файлы для создания:**
- `resources/js/components/admin/OrderStatusHistory.vue`

**Файлы для изменения:**
- `app/Http/Controllers/Api/v1/OrderController.php`
- `resources/js/pages/admin/OrderDetail.vue` (или аналогичная страница заказа)
- `routes/api.php`

---

**Статус:** ✅ Пункт 16 завершен

---

## Дополнительные предложения и улучшения

### А. Обработка ошибок и edge cases

#### А.1 Валидация прав доступа
- Проверять права пользователя перед каждым действием (роль, принадлежность заказа)
- Обрабатывать случаи, когда пользователь не имеет прав на действие
- Отправлять понятные сообщения об ошибках

#### А.2 Защита от дублирования действий
- Проверять текущий статус заказа перед изменением
- Обрабатывать случаи, когда заказ уже в нужном статусе
- Защита от одновременных изменений (оптимистическая блокировка)

#### А.3 Обработка недоступных пользователей
- Если пользователь заблокирован (`is_blocked = true`), не отправлять уведомления
- Логировать попытки отправки уведомлений заблокированным пользователям
- Для курьеров: проверять доступность перед назначением

#### А.4 Таймауты и повторные попытки
- Обрабатывать ошибки Telegram API (429 Rate Limit, временные ошибки)
- Реализовать retry logic для критических уведомлений
- Очередь для отправки уведомлений (использовать Laravel Queues)

### Б. Улучшения UX

#### Б.1 Обновление сообщений вместо создания новых
- Использовать `editMessageText` для обновления существующих сообщений
- Хранить `message_id` в metadata заказа или в отдельной таблице
- Уменьшить количество сообщений в чатах

#### Б.2 Информативные уведомления
- Включать краткую информацию о заказе в каждое уведомление (номер, сумма, адрес)
- Использовать эмодзи для визуального разделения типов уведомлений
- Форматирование сообщений (HTML parse_mode) для читабельности

#### Б.3 Кнопка "Посмотреть детали заказа"
- Для всех уведомлений добавить кнопку "Посмотреть детали"
- Отправлять полную информацию о заказе при нажатии
- Форматировать информацию о товарах, адресе, клиенте

### В. Дополнительные функции

#### В.1 Напоминания и автоматические действия
- Напоминание кухне, если заказ долго не принят (например, через 5 минут)
- Напоминание администратору о необработанных заказах
- Автоматическое изменение статуса при истечении времени выполнения

#### В.2 Статистика и аналитика
- Время обработки заказа на каждом этапе
- Среднее время выполнения на кухне
- Производительность курьеров
- Частота отмен заказов

#### В.3 Управление несколькими кухнями/курьерами
- Распределение заказов между несколькими кухнями (round-robin, по загрузке)
- Приоритизация курьеров (ближайшие, свободные)
- Геолокация курьеров (если доступна)

#### В.4 Возвраты и проблемы с заказом
- Кнопка "Проблема с заказом" для курьера и клиента
- Обработка жалоб и возвратов
- Уведомление администратора о проблемах

### Г. Технические улучшения

#### Г.1 Кэширование
- Кэшировать список курьеров для быстрого доступа
- Кэшировать информацию о пользователях
- Инвалидация кэша при изменении данных

#### Г.2 Логирование
- Расширенное логирование всех действий с заказами
- Логирование ошибок с контекстом (заказ, пользователь, статус)
- Мониторинг производительности (время выполнения операций)

#### Г.3 Тестирование
- Unit тесты для сервисов (OrderStatusService, OrderNotificationService)
- Integration тесты для callback handlers
- Тесты для валидации переходов статусов

#### Г.4 Безопасность
- Валидация всех входных данных
- Защита от SQL injection (использовать Eloquent)
- Защита от XSS в сообщениях
- Проверка подлинности callback_query (сравнение telegram_id)

### Д. Порядок реализации (рекомендации)

1. **Базовая инфраструктура (Пункты 1-5)**: Сначала создать модели, сервисы, базовые методы
2. **Обработка callback (Пункт 9)**: Реализовать инфраструктуру для обработки callback_query
3. **Уведомление администратора (Пункт 6)**: Начать с уведомлений при создании заказа
4. **Работа кухни (Пункты 10-12, 7)**: Реализовать весь flow кухни последовательно
5. **Работа курьера (Пункты 13-14, 8)**: Реализовать весь flow курьера
6. **Отмена заказа (Пункт 15)**: Реализовать функционал отмены
7. **Админ-панель (Пункт 16)**: В последнюю очередь - отображение истории

### Е. Важные замечания

#### Е.1 Статус "preparing"
- В пункте 7 указано изменение статуса с `preparing` на `ready_for_delivery`
- Но переход `kitchen_accepted → preparing` не описан детально
- Рекомендация: после принятия заказа кухней (`kitchen_accepted`) автоматически или через кнопку менять статус на `preparing`
- Либо объединить статусы `kitchen_accepted` и `preparing` (использовать только `preparing`)

#### Е.2 Хранение message_id для обновления сообщений
- Рассмотреть создание таблицы `order_notifications` для хранения связи заказ-сообщение-пользователь
- Поля: `order_id`, `telegram_user_id`, `message_id`, `notification_type`, `created_at`
- Это позволит обновлять сообщения вместо создания новых

#### Е.3 Обработка причин отмены (Пункт 15)
- Временное состояние пользователя можно хранить в Redis/Cache с ключом `cancel_order:{telegram_user_id}`
- TTL: 10-15 минут
- Альтернатива: использовать таблицу `pending_user_actions` для более надежного хранения

#### Е.4 Множественные администраторы
- Если несколько администраторов, все должны получать уведомления
- При нажатии кнопки одним администратором, другим нужно обновить/удалить кнопки (если возможно)
- Или использовать "первый ответ" - кто первым нажал, тот обработал

---

**Статус:** ✅ Дополнительные предложения добавлены

---
